#include <windows.h>
#include <dbghelp.h>
#include <stdlib.h>
#include <iostream>
#include <sstream>
#include "aes.h"
#pragma comment(lib, "dbghelp.lib")

#define CBC 1

typedef unsigned __int64 QWORD;

typedef struct PE {
	PIMAGE_DOS_HEADER     DosHeader;
	PIMAGE_NT_HEADERS     NtHeader;
	PIMAGE_OPTIONAL_HEADER OptionalHeader;
	PIMAGE_FILE_HEADER     FileHeader;
	PIMAGE_SECTION_HEADER SectionHeader;
	QWORD                 ImageBase;
	QWORD                 oep;
} PE;

typedef struct SectionConfig {
	CHAR* name;
	QWORD vaddr;
	QWORD vsize;
	QWORD raddr;
	DWORD rsize;
	QWORD* characteristic;
} SectionConfig;


void Err(const char* msg) {
	MessageBox(NULL, TEXT(msg), TEXT("Error"), MB_OK | MB_ICONERROR);
}

void DbgPrint(const char* fmt, ...) {
	char buf[256];
	va_list v1;
	va_start(v1, fmt);
	vsnprintf(buf, sizeof(buf), fmt, v1);
	va_end(v1);
	OutputDebugString(buf);
}

void ParsePE(PE* pe, UCHAR* lpTargetBinBuffer) {
	pe->DosHeader      = (PIMAGE_DOS_HEADER)lpTargetBinBuffer;
	pe->NtHeader       = (PIMAGE_NT_HEADERS)((QWORD)lpTargetBinBuffer + pe->DosHeader->e_lfanew);
	pe->OptionalHeader = &pe->NtHeader->OptionalHeader;
	pe->FileHeader     = &pe->NtHeader->FileHeader;
	pe->ImageBase      = pe->OptionalHeader->ImageBase;
	pe->oep            = pe->ImageBase + pe->OptionalHeader->AddressOfEntryPoint;
	DbgPrint("ImageBase:0x%I64X, OEP:0x%I64X", pe->ImageBase, pe->oep + pe->ImageBase);
}

void ShiftAddrOfHeaders(PE* pe, UCHAR* lpTargetBinBuffer, UINT *sizeIncrease) {
	// shift optional header addresses
	pe->oep += *sizeIncrease;
	pe->OptionalHeader->BaseOfCode += *sizeIncrease;
	
	// shift each data directories' vaddr
	PIMAGE_DATA_DIRECTORY dataDirectory = (PIMAGE_DATA_DIRECTORY)(pe->NtHeader->OptionalHeader.DataDirectory);
	for (int i = 0; i < 16; i++) {
		if (dataDirectory[i].VirtualAddress != 0) {
			dataDirectory[i].VirtualAddress += *sizeIncrease;
			DbgPrint("%d dataDirectory present", i);
		}

		// if it is Relocation Directory
		if (i == 5) {
			QWORD relocDirAddr = (QWORD)lpTargetBinBuffer + (QWORD)dataDirectory[i].VirtualAddress;
			DWORD relocDirSize = dataDirectory[i].Size;

			while (relocDirSize > 0) {
				*(QWORD*)relocDirAddr += *sizeIncrease;
				PIMAGE_BASE_RELOCATION relocDir = (PIMAGE_BASE_RELOCATION)relocDirAddr;
				relocDirSize -= relocDir->SizeOfBlock;
				relocDirAddr += relocDir->SizeOfBlock;
			}
		}

		// if it is Debug Directory
		if (i == 6) {
			PIMAGE_DEBUG_DIRECTORY debugDir = (PIMAGE_DEBUG_DIRECTORY)(lpTargetBinBuffer + (QWORD)dataDirectory[i].VirtualAddress);
			debugDir->AddressOfRawData += *sizeIncrease;
			debugDir->PointerToRawData += *sizeIncrease;
		}
	}

	// shift each section header's vaddr
	QWORD sectionLocation = (QWORD)IMAGE_FIRST_SECTION(pe->NtHeader);
	QWORD sectionSize = (QWORD)sizeof(IMAGE_SECTION_HEADER);

	for (int i = 0; i < pe->FileHeader->NumberOfSections; i++) {
		pe->SectionHeader = (PIMAGE_SECTION_HEADER)sectionLocation;
		// shifted all sections so shift header's vaddr and raddr too
		pe->SectionHeader->VirtualAddress += *sizeIncrease;
		pe->SectionHeader->PointerToRawData += *sizeIncrease;
		sectionLocation += sectionSize;
	}
}

void FindSection(PE* pe, SectionConfig* target, SectionConfig* ext) {
	QWORD sectionLocation = (QWORD)IMAGE_FIRST_SECTION(pe->NtHeader);
	QWORD sectionSize = (QWORD)sizeof(IMAGE_SECTION_HEADER);

	for (int i = 0; i < pe->FileHeader->NumberOfSections; i++) {
		pe->SectionHeader = (PIMAGE_SECTION_HEADER)sectionLocation;
		QWORD SectionTopAddr = pe->ImageBase + pe->SectionHeader->VirtualAddress;
		QWORD SectionEndAddr = pe->ImageBase + pe->SectionHeader->VirtualAddress + pe->SectionHeader->Misc.VirtualSize;

		// section that has oep
		if (SectionTopAddr <= pe->oep && pe->oep < SectionEndAddr) {
			target->name  = (CHAR*)pe->SectionHeader->Name;
			target->vaddr = pe->ImageBase + pe->SectionHeader->VirtualAddress;
			target->vsize = pe->SectionHeader->Misc.VirtualSize;
			target->raddr = pe->SectionHeader->PointerToRawData;
			target->rsize = pe->SectionHeader->SizeOfRawData;
			target->characteristic = (QWORD*)&(pe->SectionHeader->Characteristics);
			DbgPrint("OEP is in %s section", target->name);
		}

		// section .ext
		if (!strcmp((CHAR*)pe->SectionHeader->Name, ".ext")) {
			ext->name  = (CHAR*)pe->SectionHeader->Name;
			ext->vaddr = pe->ImageBase + pe->SectionHeader->VirtualAddress;
			ext->vsize = pe->SectionHeader->Misc.VirtualSize;
			ext->raddr = pe->SectionHeader->PointerToRawData;
			ext->rsize = pe->SectionHeader->SizeOfRawData;
		}

		sectionLocation += sectionSize;
	}
}

uint8_t aes128key[16] = {
	0x30, 0xee, 0xa0, 0x1b, 0xe7, 0x9e, 0x45, 0x79, 0x82, 0x58, 0x44, 0xd9, 0x17, 0x36, 0xfc, 0x59
};

uint8_t iv[16] = {
	0x30, 0xee, 0xa0, 0x1b, 0xe7, 0x9e, 0x45, 0x79, 0x82, 0x58, 0x44, 0xd9, 0x17, 0x36, 0xfc, 0x59
};

void aes_encrypt(UCHAR* start, DWORD size) {
	size_t keySize = sizeof(aes128key);
	if (keySize != 16)
		DbgPrint("WRONG KEY SIZE!!! %d", keySize);

	DbgPrint("original: %2X %2X %2X %2X %2X %2X %2X %2X", start[0], start[1], start[2], start[3], start[4], start[5], start[6], start[7]);
	struct AES_ctx ctx;
	AES_init_ctx_iv(&ctx, aes128key, iv);
	DWORD encSize = (size / 16) * 16;
	DbgPrint("AES Encrypt leftover: %d bytes", size % 16);
	AES_CBC_encrypt_buffer(&ctx, start, encSize);
	return;
}


UCHAR decodeStub[] = {
	// 256 rsbox
	// 0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    A,    B,    C,    D,    E,    F
	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,

	// 11 Rcon
	0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36,

	// ===== -21 Bytes from original code =====

	// 256 sbox
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,

	// ===== -8 Bytes from original code =====
	
	// 201 CopyMem func
	0x49, 0x89, 0xc8, 0x48, 0x89, 0xd0, 0x48, 0x39, 0xd1, 0x0f, 0x84, 0xb7, 0x00, 0x00, 0x00, 0x48, 0x89, 0xca, 0x48, 0x09, 0xc2, 0xf6, 0xc2, 0x07, 0x75, 0x33, 0x48, 0x39, 0xc1, 0x73, 0x13, 0x48, 0x8b, 0x10, 0x48, 0x89, 0x11, 0x48, 0x8b, 0x40, 0x08, 0x48, 0x89, 0x41, 0x08, 0xe9, 0x94, 0x00, 0x00, 0x00, 0x0f, 0x86, 0x8e, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x48, 0x08, 0x48, 0x83, 0xc0, 0x10, 0x49, 0x89, 0x48, 0x08, 0x48, 0x8b, 0x40, 0xf0, 0x49, 0x89, 0x00, 0xeb, 0x79, 0x83, 0xe2, 0x03, 0x75, 0x3a, 0x48, 0x39, 0xc1, 0x73, 0x17, 0x44, 0x8b, 0x0c, 0x10, 0x49, 0x8d, 0x0c, 0x10, 0x48, 0x83, 0xc2, 0x04, 0x44, 0x89, 0x09, 0x48, 0x83, 0xfa, 0x10, 0x75, 0xeb, 0xeb, 0x58, 0x76, 0x56, 0xba, 0x0c, 0x00, 0x00, 0x00, 0x44, 0x8b, 0x0c, 0x10, 0x49, 0x8d, 0x0c, 0x10, 0x48, 0x83, 0xea, 0x04, 0x44, 0x89, 0x09, 0x48, 0x83, 0xfa, 0xfc, 0x75, 0xeb, 0xeb, 0x3a, 0x48, 0x39, 0xc1, 0x73, 0x18, 0x31, 0xd2, 0x49, 0x8d, 0x0c, 0x10, 0x48, 0x83, 0xfa, 0x10, 0x74, 0x29, 0x44, 0x8a, 0x0c, 0x10, 0x48, 0xff, 0xc2, 0x44, 0x88, 0x09, 0xeb, 0xea, 0x76, 0x1b, 0xba, 0x0f, 0x00, 0x00, 0x00, 0x49, 0x8d, 0x0c, 0x10, 0x48, 0x83, 0xfa, 0xff, 0x74, 0x0c, 0x44, 0x8a, 0x0c, 0x10, 0x48, 0xff, 0xca, 0x44, 0x88, 0x09, 0xeb, 0xea, 0x4c, 0x89, 0xc0, 0xc3,
	

	// EfiMain
	0x90, 0x90,                                                   // 2 deadloop for debug (eb fe)
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,               // 8 push registers
	0x48, 0xb8, 0x6c, 0x76, 0x7f, 0x60, 0x55, 0x74, 0xbe, 0x42, 0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x55, 0x57, 0x56, 0x53, 0x48, 0x81, 0xec, 0xa8, 0x05, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x7c, 0x48, 0x8d, 0x4c, 0x24, 0x7c, 0x4c, 0x8d, 0x44, 0x24, 0x70, 0x48, 0xb8, 0x93, 0x0b, 0xe4, 0xd7, 0x6d, 0xb2, 0x72, 0x0f, 0x48, 0x89, 0x84, 0x24, 0x84, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x42, 0x60, 0x31, 0xd2, 0xff, 0x90, 0x40, 0x01, 0x00, 0x00, 0x48, 0x8d, 0x94, 0x24, 0x90, 0x01, 0x00, 0x00, 0x48, 0xb8, 0x80, 0x02, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x41, 0xb9, 0x10, 0x04, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0xad, 0x00, 0x00, 0x00, 0x48, 0xb8, 0x01, 0x4e, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x4c, 0x8d, 0x84, 0x24, 0xad, 0x00, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0xb5, 0x00, 0x00, 0x00, 0xb8, 0x09, 0x40, 0x00, 0x00, 0x48, 0xc1, 0xe0, 0x28, 0x48, 0x89, 0x54, 0x24, 0x20, 0xba, 0x23, 0x00, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0xbd, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x44, 0x24, 0x70, 0x48, 0xc7, 0x84, 0x24, 0xc5, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x66, 0xc7, 0x84, 0x24, 0xcd, 0x00, 0x00, 0x00, 0x10, 0x00, 0x48, 0x89, 0xc1, 0xc6, 0x84, 0x24, 0xcf, 0x00, 0x00, 0x00, 0x00, 0xff, 0x50, 0x18, 0x31, 0xc0, 0x4c, 0x8d, 0x94, 0x24, 0x8d, 0x00, 0x00, 0x00, 0x4c, 0x8d, 0x8c, 0x24, 0x9c, 0x00, 0x00, 0x00, 0x4c, 0x8d, 0x84, 0x24, 0xa0, 0x01, 0x00, 0x00, 0x41, 0x8a, 0x0c, 0x00, 0x4c, 0x89, 0xca, 0x48, 0x29, 0xc2, 0x48, 0xff, 0xc0, 0x88, 0x0a, 0x48, 0x83, 0xf8, 0x10, 0x75, 0xeb, 0x48, 0x8d, 0xb4, 0x24, 0xd0, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xd0, 0x48, 0x8d, 0x8c, 0x24, 0x9d, 0x00, 0x00, 0x00, 0x48, 0x89, 0x74, 0x24, 0x38, 0x48, 0x89, 0xf2, 0x44, 0x8a, 0x00, 0x48, 0x83, 0xc0, 0x04, 0x48, 0x83, 0xc2, 0x04, 0x44, 0x88, 0x42, 0xfc, 0x44, 0x8a, 0x40, 0xfd, 0x44, 0x88, 0x42, 0xfd, 0x44, 0x8a, 0x40, 0xfe, 0x44, 0x88, 0x42, 0xfe, 0x44, 0x8a, 0x40, 0xff, 0x44, 0x88, 0x42, 0xff, 0x48, 0x39, 0xc1, 0x75, 0xd4, 0x48, 0x8b, 0x44, 0x24, 0x38, 0x41, 0xbb, 0x04, 0x00, 0x00, 0x00, // 329
	0x48, 0x8d, 0x1d, 0xDC, 0xfc, 0xff, 0xff,                     // 7 lea rbx, [sbox]
	0x48, 0x8d, 0x35, 0xCA, 0xfc, 0xff, 0xff,                     // 7 lea rsi, [Rcon]
	0x44, 0x0f, 0xb6, 0x40, 0x0c, 0x0f, 0xb6, 0x48, 0x0d, 0x44, 0x0f, 0xb6, 0x48, 0x0e, 0x0f, 0xb6, 0x50, 0x0f, 0x41, 0xf6, 0xc3, 0x03, 0x75, 0x1e, 0x40, 0x8a, 0x3c, 0x0b, 0x42, 0x8a, 0x0c, 0x0b, 0x44, 0x8a, 0x0c, 0x13, 0x42, 0x8a, 0x14, 0x03, 0x45, 0x89, 0xd8, 0x41, 0xc1, 0xe8, 0x02, 0x42, 0x32, 0x3c, 0x06, 0x41, 0x89, 0xf8, 0x44, 0x32, 0x00, 0x32, 0x48, 0x01, 0x41, 0xff, 0xc3, 0x48, 0x83, 0xc0, 0x04, 0x44, 0x32, 0x48, 0xfe, 0x32, 0x50, 0xff, 0x44, 0x88, 0x40, 0x0c, 0x88, 0x48, 0x0d, 0x44, 0x88, 0x48, 0x0e, 0x88, 0x50, 0x0f, 0x41, 0x83, 0xfb, 0x2c, 0x75, 0xa2, 0x4c, 0x89, 0xd2, 0x48, 0x8d, 0x8c, 0x24, 0x80, 0x01, 0x00, 0x00, 0x41, 0xb8, 0x10, 0x00, 0x00, 0x00, 0x41, 0xb3, 0x1b, // 114
	0xe8, 0x5E, 0xfd, 0xff, 0xff,                                 // [5] call CopyMem
	0x53,                                                         // 1 push rbx                <= save rbx
	0xE8, 0x00, 0x00, 0x00, 0x00,                                 // 5 call $+5			    
	0x5b,                                                         // 1 pop rbx                 <=  current instruction address will be set to rbx
	0x48, 0x81, 0xEB, 0xFF, 0xFF, 0xFF, 0xFF,                     // 7 sub rbx, offset         <=  rbx will contain base address of this module  
	0x49, 0xba, 0x11, 0x22, 0x33, 0x44, 0x44, 0x33, 0x22, 0x11,   // 10 mov r10, SystemVaddr
	0x49, 0x01, 0xda,                                             // 3 add r10, rbx		    
	0x5b,                                                         // 1 pop rbx                 <= restore rbx
	0x48, 0xb8, 0x55, 0x66, 0x77, 0x88, 0x88, 0x77, 0x66, 0x55,   // 10 mov rax, DecryptSize
	0x48, 0x89, 0x44, 0x24, 0x68, 0x48, 0x8b, 0x44, 0x24, 0x68, 0x89, 0x44, 0x24, 0x4c, 0x4C, 0x89, 0x15, 0x3C, 0x03, 0x00, 0x00, 0x4C, 0x89, 0xD0, 0x48, 0x2B, 0x05, 0x32, 0x03, 0x00, 0x00, 0x39, 0x44, 0x24, 0x4c, 0x0f, 0x86, 0x06, 0x03, 0x00, 0x00, 0x48, 0x8d, 0x8c, 0x24, 0x9d, 0x00, 0x00, 0x00, 0x41, 0xb8, 0x10, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xd2, // 58
	0xe8, 0xF9, 0xFC, 0xff, 0xff,                                 // [5] call CopyMem
	0x48, 0x8b, 0x74, 0x24, 0x38, 0x31, 0xc0, 0x4c, 0x8d, 0x8e, 0xa0, 0x00, 0x00, 0x00, 0x49, 0x8d, 0x0c, 0x02, 0x31, 0xd2, 0x4d, 0x8d, 0x04, 0x01, 0x41, 0x8a, 0x1c, 0x10, 0x48, 0xff, 0xc2, 0x30, 0x19, 0x48, 0xff, 0xc1, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xee, 0x48, 0x83, 0xc0, 0x04, 0x48, 0x83, 0xf8, 0x10, 0x75, 0xda, 0x48, 0x8b, 0x44, 0x24, 0x38, 0xc7, 0x44, 0x24, 0x48, 0x24, 0x00, 0x00, 0x00, 0x48, 0x05, 0x90, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x40, 0x49, 0x8d, 0x42, 0x04, 0x48, 0x89, 0x44, 0x24, 0x50, 0x49, 0x8d, 0x42, 0x10, 0x48, 0x89, 0x44, 0x24, 0x58, 0x41, 0x8a, 0x52, 0x09, 0x41, 0x8a, 0x42, 0x0d, 0x41, 0x88, 0x52, 0x0d, 0x41, 0x8a, 0x52, 0x05, 0x41, 0x88, 0x52, 0x09, 0x41, 0x8a, 0x52, 0x01, 0x41, 0x88, 0x42, 0x01, 0x41, 0x8a, 0x42, 0x02, 0x41, 0x88, 0x52, 0x05, 0x41, 0x8a, 0x52, 0x0a, 0x41, 0x88, 0x42, 0x0a, 0x41, 0x8a, 0x42, 0x06, 0x41, 0x88, 0x52, 0x02, 0x41, 0x8a, 0x52, 0x0e, 0x41, 0x88, 0x42, 0x0e, 0x41, 0x8a, 0x42, 0x03, 0x41, 0x88, 0x52, 0x06, 0x41, 0x8a, 0x52, 0x07, 0x41, 0x88, 0x52, 0x03, 0x41, 0x8a, 0x52, 0x0b, 0x41, 0x88, 0x52, 0x07, 0x41, 0x8a, 0x52, 0x0f, 0x41, 0x88, 0x42, 0x0f, 0x41, 0x88, 0x52, 0x0b, 0x4c, 0x89, 0xd2, 0x48, 0x89, 0xd0, 0x31, 0xc9, 0x44, 0x0f, 0xb6, 0x00, // [202]
	0x48, 0x8d, 0x3d, 0x1D, 0xfa, 0xff, 0xff,                     // 7 lea rdi, [rsbox]
	0xff, 0xc1, 0x48, 0x83, 0xc0, 0x04, 0x46, 0x8a, 0x04, 0x07, 0x44, 0x88, 0x40, 0xfc, 0x80, 0xf9, 0x04, 0x75, 0xe2, 0x48, 0xff, 0xc2, 0x48, 0x39, 0x54, 0x24, 0x50, 0x75, 0xd3, 0x31, 0xc0, 0x48, 0x8b, 0x74, 0x24, 0x40, 0x49, 0x8d, 0x0c, 0x02, 0x31, 0xd2, 0x4c, 0x8d, 0x04, 0x06, 0x45, 0x8a, 0x0c, 0x10, 0x48, 0xff, 0xc2, 0x44, 0x30, 0x09, 0x48, 0xff, 0xc1, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xed, 0x48, 0x83, 0xc0, 0x04, 0x48, 0x83, 0xf8, 0x10, 0x75, 0xd4, 0x83, 0x7c, 0x24, 0x48, 0x00, 0x0f, 0x84, 0x93, 0x01, 0x00, 0x00, 0x4c, 0x89, 0xd1, 0x8a, 0x41, 0x01, 0x44, 0x8a, 0x01, 0x88, 0x44, 0x24, 0x35, 0x8a, 0x41, 0x02, 0x43, 0x8d, 0x14, 0x00, 0x88, 0x44, 0x24, 0x34, 0x44, 0x89, 0xc0, 0xc0, 0xe8, 0x07, 0x41, 0x0f, 0xaf, 0xc3, 0x31, 0xc2, 0x89, 0xd0, 0x89, 0xd3, 0x88, 0x54, 0x24, 0x36, 0xc0, 0xe8, 0x07, 0x8d, 0x14, 0x1b, 0x8a, 0x5c, 0x24, 0x35, 0x41, 0x0f, 0xaf, 0xc3, 0x44, 0x8d, 0x3c, 0x1b, 0x31, 0xc2, 0x89, 0xd0, 0x89, 0xd7, 0x88, 0x54, 0x24, 0x37, 0xc0, 0xe8, 0x07, 0x8d, 0x34, 0x3f, 0x40, 0x8a, 0x7c, 0x24, 0x34, 0x41, 0x0f, 0xaf, 0xc3, 0x44, 0x8d, 0x34, 0x3f, 0x40, 0x8a, 0x79, 0x03, 0x31, 0xc6, 0x8a, 0x44, 0x24, 0x35, 0x44, 0x8d, 0x24, 0x3f, 0xc0, 0xe8, 0x07, 0x41, 0x0f, 0xaf, 0xc3, 0x41, 0x31, 0xc7, 0x44, 0x89, 0xf8, 0x43, 0x8d, 0x2c, 0x3f, 0xc0, 0xe8, 0x07, 0x41, 0x0f, 0xaf, 0xc3, 0x31, 0xc5, 0x89, 0xe8, 0x8d, 0x5c, 0x2d, 0x00, 0xc0, 0xe8, 0x07, 0x41, 0x0f, 0xaf, 0xc3, 0x31, 0xc3, 0x8a, 0x44, 0x24, 0x34, 0xc0, 0xe8, 0x07, 0x41, 0x0f, 0xaf, 0xc3, 0x41, 0x31, 0xc6, 0x44, 0x89, 0xf0, 0x47, 0x8d, 0x2c, 0x36, 0xc0, 0xe8, 0x07, 0x41, 0x0f, 0xaf, 0xc3, 0x41, 0x31, 0xc5, 0x44, 0x89, 0xe8, 0x47, 0x8d, 0x4c, 0x2d, 0x00, 0xc0, 0xe8, 0x07, 0x41, 0x0f, 0xaf, 0xc3, 0x41, 0x31, 0xc1, 0x8a, 0x41, 0x03, 0xc0, 0xe8, 0x07, 0x41, 0x0f, 0xaf, 0xc3, 0x41, 0x31, 0xc4, 0x44, 0x89, 0xe0, 0x43, 0x8d, 0x3c, 0x24, 0xc0, 0xe8, 0x07, 0x41, 0x0f, 0xaf, 0xc3, 0x31, 0xc7, 0x89, 0xf8, 0x8d, 0x14, 0x3f, 0xc0, 0xe8, 0x07, 0x41, 0x0f, 0xaf, 0xc3, 0x31, 0xd0, 0x8a, 0x54, 0x24, 0x35, 0x33, 0x54, 0x24, 0x34, 0x32, 0x51, 0x03, 0x32, 0x54, 0x24, 0x36, 0x44, 0x31, 0xfa, 0x32, 0x54, 0x24, 0x37, 0x44, 0x31, 0xea, 0x31, 0xf2, 0x31, 0xda, 0x44, 0x31, 0xca, 0x31, 0xc2, 0x88, 0x11, 0x8a, 0x54, 0x24, 0x34, 0x44, 0x31, 0xc2, 0x32, 0x51, 0x03, 0x44, 0x32, 0x44, 0x24, 0x35, 0x44, 0x31, 0xfa, 0x44, 0x31, 0xf2, 0x31, 0xea, 0x31, 0xfa, 0x31, 0xf2, 0x31, 0xda, 0x44, 0x31, 0xca, 0x31, 0xc2, 0x88, 0x51, 0x01, 0x8a, 0x51, 0x03, 0x44, 0x31, 0xc2, 0x44, 0x31, 0xf2, 0x44, 0x31, 0xe2, 0x32, 0x54, 0x24, 0x37, 0x44, 0x31, 0xea, 0x31, 0xf2, 0x31, 0xda, 0x44, 0x31, 0xca, 0x48, 0x83, 0xc1, 0x04, 0x31, 0xc2, 0x88, 0x51, 0xfe, 0x8a, 0x54, 0x24, 0x34, 0x44, 0x31, 0xc2, 0x32, 0x54, 0x24, 0x36, 0x44, 0x31, 0xe2, 0x31, 0xea, 0x31, 0xfa, 0x31, 0xf2, 0x31, 0xda, 0x44, 0x31, 0xca, 0x31, 0xc2, 0x88, 0x51, 0xff, 0x48, 0x39, 0x4c, 0x24, 0x58, 0x0f, 0x85, 0x80, 0xfe, 0xff, 0xff, 0x48, 0x83, 0x6c, 0x24, 0x40, 0x10, 0x83, 0x6c, 0x24, 0x48, 0x04, 0xe9, 0xa4, 0xfd, 0xff, 0xff, 0x31, 0xc0, 0x48, 0x8d, 0x8c, 0x24, 0x80, 0x01, 0x00, 0x00, 0x8a, 0x14, 0x01, 0x41, 0x30, 0x14, 0x02, 0x48, 0xff, 0xc0, 0x48, 0x83, 0xf8, 0x10, 0x75, 0xf0, 0x48, 0x8d, 0x94, 0x24, 0x9d, 0x00, 0x00, 0x00, 0x41, 0xb8, 0x10, 0x00, 0x00, 0x00, 0x49, 0x83, 0xc2, 0x10, // [533]
	0xe8, 0x0E, 0xfa, 0xff, 0xff,                                 // [5] call CopyMem
	0xe9, 0xE6, 0xfc, 0xff, 0xff,                                 // [5]
	0x48, 0x81, 0xC4, 0xA8, 0x05, 0x00, 0x00, 0x5B, 0x5E, 0x5F, 0x5D, 0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E, 0x41, 0x5F,   // 19 add rsp,0x5a8; pop rbx; pop rsi; pop rdi; pop rbp; pop r12; pop r13; pop r14; pop r15
	0x5F, 0x5E, 0x5D, 0x5C, 0x5B, 0x5A, 0x59, 0x58,               // 8 pop registers
	0xE9, 0xF9, 0xFF, 0xFF, 0xFF                                  // 5 jmp oep
};

UINT extEfiMainOffset = 0;
void CreateDecodeStub(QWORD SectionVaddr, QWORD SectionVsize, QWORD oep, QWORD extRaddr, DWORD decodeStubOffset) {
	extEfiMainOffset = 256 + 11 + 256 + 201;
	UINT offsetOffset = extEfiMainOffset + 2 + 8 + 329 + 7 + 7 + 114 + 5 + 1 + 5 + 1 + 4;
	UINT decodeStartOffset = offsetOffset + 3 + 3;
	UINT decodeSizeOffset = decodeStartOffset + 7 + 3 + 1 + 3;
	UINT jmpOepAddrOffset = decodeSizeOffset + 7 + 58 + 5 + 202 + 7 + 533 + 5 + 5 + 19 + 8 + 2;
	long oepOffset = oep - (extRaddr + jmpOepAddrOffset - 1) - 5;
	DWORD offset = decodeStubOffset + (extEfiMainOffset + 2 + 8 + 329 + 7 + 7 + 114 + 5 + 1 + 5 + 1);

	QWORD DecryptSize = (SectionVsize / 16) * 16;

	memcpy(&decodeStub[offsetOffset], &offset, sizeof(DWORD));
	memcpy(&decodeStub[decodeStartOffset], &SectionVaddr, sizeof(QWORD));
	memcpy(&decodeStub[decodeSizeOffset], &DecryptSize, sizeof(QWORD));
	memcpy(&decodeStub[jmpOepAddrOffset], &oepOffset, sizeof(DWORD));
	return;
}

UCHAR* ReadTargetFile(WCHAR* lpTargetFilename, DWORD* dwTargetBinSize, UINT extSize, UINT extHeaderSize) {
	HANDLE hTargetBin;
	DWORD dwReadSize;
	UCHAR* lpTargetBinBuffer;
	bool bRes;

	hTargetBin = CreateFileW(lpTargetFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hTargetBin == INVALID_HANDLE_VALUE) {
		Err("No Such File");
		return 0;
	}

	*dwTargetBinSize = GetFileSize(hTargetBin, NULL);
	if (*dwTargetBinSize == -1) {
		Err("Failed to get file size");
		return 0;
	}

	DWORD newSize = *dwTargetBinSize + (DWORD)extSize + (DWORD)extHeaderSize + (DWORD)0x1000;
	// 0x1000 is a buffer since we extend more than extHeaderSize due to section alignment
	// if extHeaderSize=0x28 and section alignment is 0x20, additional 0x40 is required
	// 0x1000-0x40 will not be included in the output file since we're specifying only the required size when WriteFile
	// 0x1000 is not enough if section alignment is more than 0x1000, In that case, error will occur in AddExtSection.

	lpTargetBinBuffer = (UCHAR*)malloc(sizeof(DWORD) * newSize);
	if (lpTargetBinBuffer == NULL) {
		Err("Failed to allocate region to read file");
		return 0;
	}
	else memset(lpTargetBinBuffer, 0, sizeof(DWORD) * newSize);

	bRes = ReadFile(hTargetBin, lpTargetBinBuffer, *dwTargetBinSize, &dwReadSize, NULL);
	if (!bRes && *dwTargetBinSize != dwReadSize) {
		Err("Failed to read file");
		return 0;
	}

	CloseHandle(hTargetBin);

	return lpTargetBinBuffer;
}

BOOL WritePackedFile(WCHAR* lpPackedFilename, UCHAR* lpTargetBinBuffer, DWORD dwTargetBinSize, SectionConfig* target, UINT extSize, UINT *sizeIncreased) {
	bool bRes;

	*(target->characteristic) |= IMAGE_SCN_MEM_WRITE;

	HANDLE hPackedBin = CreateFileW(lpPackedFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hPackedBin == INVALID_HANDLE_VALUE) {
		Err("No Such File");
		return FALSE;
	}

	DWORD dwWriteSize;
	bRes = WriteFile(hPackedBin, lpTargetBinBuffer, dwTargetBinSize + (DWORD)extSize + (DWORD)(*sizeIncreased), &dwWriteSize, NULL);
	if (!bRes && (dwTargetBinSize + (DWORD)extSize + (DWORD)(*sizeIncreased)) != dwWriteSize) {
		Err("Write Failed");
		return FALSE;
	}

	CloseHandle(hPackedBin);

	return TRUE;
}

void AddExtSection(PE* pe, UCHAR* lpTargetBinBuffer, DWORD dwTargetBinSize, UINT extSize, UINT extHeaderSize, UINT* sizeIncrease) {
	// appending additional data on EOF is done in ReadTargetFile

	// change size of image
	DWORD newSizeOfImage = 0;
	while (newSizeOfImage <= extSize)
		newSizeOfImage += pe->OptionalHeader->SectionAlignment;

	pe->OptionalHeader->SizeOfImage += newSizeOfImage;
	
	// determine ext location and section before ext
	QWORD extSecHeaderLocation = (QWORD)IMAGE_FIRST_SECTION(pe->NtHeader) + ((QWORD)sizeof(IMAGE_SECTION_HEADER) * pe->FileHeader->NumberOfSections);
	PIMAGE_SECTION_HEADER extSecHeader = (PIMAGE_SECTION_HEADER)(extSecHeaderLocation);
	QWORD beforeSecHeaderLocation = (QWORD)IMAGE_FIRST_SECTION(pe->NtHeader) + ((QWORD)sizeof(IMAGE_SECTION_HEADER) * (pe->FileHeader->NumberOfSections - 1));
	PIMAGE_SECTION_HEADER beforeSecHeader = (PIMAGE_SECTION_HEADER)beforeSecHeaderLocation;

	// change number of sections
	pe->FileHeader->NumberOfSections += 1;
	DbgPrint("extSecHeaderLocation: 0x%I64X, NumberOfSections: %d", extSecHeaderLocation, pe->FileHeader->NumberOfSections);
	DbgPrint("beforeSecHeaderLocation: 0x%I64X, beforeSecHeader: %s", beforeSecHeaderLocation, beforeSecHeader->Name);
	

	// shift all other sections (to allocate space for ext section header attributes entry)
	//  dwTargetBinSize(whole file size) = headerSize + sectionsSize
	if (pe->OptionalHeader->SectionAlignment > 0x1000)
		Err("increase buffer to more than 0x1000");

	*sizeIncrease = 0;
	while (*sizeIncrease <= extHeaderSize)
		*sizeIncrease += pe->OptionalHeader->SectionAlignment; // sections need to be aligned
	pe->OptionalHeader->SizeOfImage += *sizeIncrease;
	pe->OptionalHeader->SizeOfHeaders += extHeaderSize;
	QWORD headerSize = extSecHeaderLocation - (QWORD)lpTargetBinBuffer;
	DWORD sectionsSize = dwTargetBinSize - headerSize;
	memmove((UCHAR*)(extSecHeaderLocation + *sizeIncrease), (UCHAR*)extSecHeaderLocation, sectionsSize);


	// change ext section attributes
	DWORD vaddrOffset = 0;
	while (vaddrOffset < beforeSecHeader->Misc.VirtualSize)
		vaddrOffset += pe->OptionalHeader->SectionAlignment;

	char secname[5] = ".ext";
	memset((char*)extSecHeader->Name, 0, 8);
	strncpy_s((char*)extSecHeader->Name, 8, secname, 5);
	extSecHeader->Misc.VirtualSize = extSize;
	extSecHeader->VirtualAddress = beforeSecHeader->VirtualAddress + vaddrOffset;
	extSecHeader->SizeOfRawData = extSize;
	extSecHeader->PointerToRawData = dwTargetBinSize;
	extSecHeader->PointerToRelocations = 0;
	extSecHeader->PointerToLinenumbers = 0;
	extSecHeader->NumberOfRelocations = 0;
	extSecHeader->NumberOfLinenumbers = 0;
	extSecHeader->Characteristics = 0x60000020;

	DbgPrint("name: %s, ext vaddr: 0x%I64X, vsize: %I32X", extSecHeader->Name, extSecHeader->VirtualAddress, extSecHeader->Misc.VirtualSize);
	DbgPrint("sizeOfRawData:%I32X, PointerToRawData: 0x%I32X", extSecHeader->SizeOfRawData, extSecHeader->PointerToRawData);
}


int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
	bool bRes;

	// handling args
	int nArgc = 0;
	WCHAR* lpCommandLine = GetCommandLineW();
	WCHAR** lppArgv = CommandLineToArgvW(lpCommandLine, &nArgc);
	WCHAR* lpTargetFilename = lppArgv[1];
	WCHAR* lpPackedFilename = lppArgv[2];

	// read target file to be packed
	// lpTargetBinBuffer : head address of target file located in memory
	DWORD dwTargetBinSize;
	UCHAR* lpTargetBinBuffer;
	UINT extSize = 2200;
	UINT extHeaderSize = 0x28; // sizeof(IMAGE_SECTION_HEADER) と同じ
	UINT sizeIncrease = 0;
	lpTargetBinBuffer = ReadTargetFile(lpTargetFilename, &dwTargetBinSize, extSize, extHeaderSize);
	DbgPrint("lpTargetBinBuffer: 0x%I64X", lpTargetBinBuffer);

	// locate address of headers
	PE* pe = (PE*)malloc(sizeof(PE));
	ParsePE(pe, lpTargetBinBuffer);


	// add ext section to put decode stub
	// also, shift all sections to allocate space for ext section header entry
	AddExtSection(pe, lpTargetBinBuffer, dwTargetBinSize, extSize, extHeaderSize, &sizeIncrease);

	// shift address value of pe header
	ShiftAddrOfHeaders(pe, lpTargetBinBuffer, &sizeIncrease);

	// find section to encrypt (target) and to put decodestub (ext)
	SectionConfig* target = (SectionConfig*)malloc(sizeof(SectionConfig));
	SectionConfig* ext = (SectionConfig*)malloc(sizeof(SectionConfig));
	FindSection(pe, target, ext);


	// encrypt section that includes entrypoint
	aes_encrypt((UCHAR*)(target->raddr + lpTargetBinBuffer), target->vsize);


	// put decode stub to ext section
	CreateDecodeStub(target->vaddr, target->vsize, pe->oep, ext->raddr, (DWORD)(ext->vaddr - pe->ImageBase));
	memcpy((UCHAR*)(ext->raddr + lpTargetBinBuffer), decodeStub, sizeof(decodeStub));
	DbgPrint("DecodeStub located to 0x%I64X", (ext->raddr + lpTargetBinBuffer));

	
	// overwrite entrypoint
	QWORD newEP = ext->vaddr - pe->ImageBase + extEfiMainOffset + 1;
	pe->OptionalHeader->AddressOfEntryPoint = newEP;
	DbgPrint("Entry Point Modified to 0x%I64X", newEP);


	// write packed file
	if (WritePackedFile(lpPackedFilename, lpTargetBinBuffer, dwTargetBinSize, target, extSize, &sizeIncrease) == FALSE) {
		Err("Writing packed file failed");
		return 1;
	}

	DbgPrint("Packing SUCCESS!!");

	// closing
	if (lpTargetBinBuffer) {
		free(lpTargetBinBuffer);
		lpTargetBinBuffer = NULL;
	}

	return 0;
}