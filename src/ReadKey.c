#include <Uefi.h>
#include <Library/UefiLib.h>
#include <Protocol/Tcg2Protocol.h>
#include <IndustryStandard/Tpm20.h>

// For Generating Shellcode to read EK and decrypt .text section
// compile this with edk2, copy assembly and split it like below
/*
0x48, 0xb8, 0x6c, 0x76, 0x7f, 0x60, 0x55, 0x74, 0xbe, 0x42, 0x41, 0x54, 0x57, 0x56, 0xbe, 0x42, 0x00, 0x00, 0x00, 0x53, 0x48, 0x89, 0xd3, 0x48, 0x81, 0xec, 0x68, 0x02, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x5c, 0x48, 0x8d, 0x4c, 0x24, 0x5c, 0x4c, 0x8d, 0x44, 0x24, 0x40, 0x48, 0xb8, 0x93, 0x0b, 0xe4, 0xd7, 0x6d, 0xb2, 0x72, 0x0f, 0x48, 0x89, 0x44, 0x24, 0x64, 0x48, 0x8b, 0x42, 0x60, 0x31, 0xd2, 0x4c, 0x8d, 0x64, 0x24, 0x38, 0xff, 0x90, 0x40, 0x01, 0x00, 0x00, 0x48, 0x8d, 0x54, 0x24, 0x6e, 0x48, 0xb8, 0x80, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x41, 0xb9, 0xf2, 0x01, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x4e, 0x48, 0x8b, 0x44, 0x24, 0x40, 0x4c, 0x8d, 0x44, 0x24, 0x4e, 0x48, 0x89, 0x54, 0x24, 0x20, 0xba, 0x0e, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc1, 0xc7, 0x44, 0x24, 0x56, 0x01, 0x73, 0x81, 0x01, 0x66, 0xc7, 0x44, 0x24, 0x5a, 0x00, 0x01, 0xff, 0x50, 0x18, 0x4c, 0x89, 0xe2, 0x48, 0xb8, 0x41, 0x00, 0x0d, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x38, 0x48, 0x8b, 0x43, 0x40, 0x48, 0x89, 0xc1, 0xff, 0x50, 0x08, 0x44, 0x8a, 0x94, 0x24, 0xd9, 0x00, 0x00, 0x00, 0x31, 0xc9, 0x31, 0xc0, 0x8b, 0x54, 0x24, 0x38, 0x41, 0xb3, 0x01,
0x49, 0xb8, 0x11, 0x22, 0x33, 0x44, 0x44, 0x33, 0x22, 0x11,   <== gonna overwrite 0x1122334444332211 with the base address of .text section when packing
0x49, 0xb9, 0x55, 0x66, 0x77, 0x88, 0x88, 0x77, 0x66, 0x55,   <== gonna overwrite 0x5566778888776655 with .text section size when packing
0x0f, 0xb6, 0xf8, 0x40, 0x8a, 0xbc, 0x3c, 0xd8, 0x00, 0x00, 0x00, 0x42, 0x30, 0x3c, 0x00, 0x48, 0x83, 0xf8, 0x01, 0x75, 0x0b, 0x41, 0x80, 0xfa, 0x8d, 0x41, 0x0f, 0x44, 0xcb, 0x0f, 0x44, 0xd6, 0x48, 0xff, 0xc0, 0x4c, 0x39, 0xc8, 0x75, 0xd8, 0x84, 0xc9, 0x74, 0x05, 0x66, 0x89, 0x54, 0x24, 0x38, 0x48, 0x8b, 0x43, 0x40, 0x4c, 0x89, 0xe2, 0x48, 0x89, 0xc1, 0xff, 0x50, 0x08,
*/
// then, copy those to the src/custom-packer.cpp
// (make sure to count the number of bytes of the above shellcode in order to memcpy value when packing)

EFI_STATUS EFIAPI UefiMain(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable) {

	EFI_GUID _gEfiTcg2ProtocolGuid = {0x607f766c, 0x7455, 0x42be, { 0x93, 0x0b, 0xe4, 0xd7, 0x6d, 0xb2, 0x72, 0x0f }};

	/*UINT32 EK_HANDLE = 0x81010001;*/
	EFI_TCG2_PROTOCOL *Tcg2Protocol;

#pragma pack(1)
	typedef struct {
		TPM2_COMMAND_HEADER Header;
		TPMI_DH_OBJECT objectHandle;
	} TPM2_READ_PUBLIC_COMMAND;

	typedef struct {
		TPM2_RESPONSE_HEADER Header;
		TPM2B_PUBLIC outPublic;
		TPM2B_NAME name;
		TPM2B_NAME qualifiedName;
	} TPM2_READ_PUBLIC_RESPONSE;
#pragma pack()
	
	SystemTable->BootServices->LocateProtocol(&_gEfiTcg2ProtocolGuid, NULL, (VOID**)&Tcg2Protocol);

	TPM2_READ_PUBLIC_COMMAND CmdBuffer;
	UINT32 CmdBufferSize;
	TPM2_READ_PUBLIC_RESPONSE RecvBuffer;
	UINT32 RecvBufferSize;

	// send
	// (command sending to TPM is BIG Endian!)
	CmdBuffer.Header.tag         = 0x0180;
	CmdBuffer.Header.commandCode = 0x73010000;
	CmdBuffer.objectHandle       = 0x01000181;
	CmdBufferSize                = 0xE;
	CmdBuffer.Header.paramSize   = 0x0E000000;

	// recv
	RecvBufferSize = sizeof(RecvBuffer);
	Tcg2Protocol->SubmitCommand(Tcg2Protocol, CmdBufferSize, (UINT8*)&CmdBuffer, RecvBufferSize, (UINT8*)&RecvBuffer);


	// debug print
	UINT64 buf = 0x0000000a000d0041; // L"A\r\n"
	CHAR16 *msg = (CHAR16*)&buf;
	SystemTable->ConOut->OutputString(SystemTable->ConOut, msg);

	// decode
	BYTE* key = RecvBuffer.outPublic.publicArea.unique.rsa.buffer;
	BYTE* SectionVaddr  = (BYTE*)0x1122334444332211;
	UINT64 SectionSize  = 0x5566778888776655;
	UINT64 i;
	for(i=0; i<SectionSize; i++) {
		SectionVaddr[i] = (SectionVaddr[i] ^ key[i%256]) & 0xff;

		// check if EK is correct
		if(i==1 && key[i]==0x8d) {
			*msg = (CHAR16)0x0000000a000d0042; // L"B\r\n"
		}
	}

	SystemTable->ConOut->OutputString(SystemTable->ConOut, msg);

	while(1);
	return 0;
}
