#include <Uefi.h>
#include <Library/UefiLib.h>
#include <Protocol/Tcg2Protocol.h>
#include <IndustryStandard/Tpm20.h>

// For Generating Shellcode to read EK and decrypt .text section
// compile this with edk2, copy assembly and split it like below
/*
=========================================================================================================================================================================================
0x48, 0xb8, 0x6c, 0x76, 0x7f, 0x60, 0x55, 0x74, 0xbe, 0x42, 0x41, 0x54, 0x55, 0x57, 0xbf, 0x42, 0x00, 0x00, 0x00, 0x56, 0x53, 0x48, 0x89, 0xd3, 0x48, 0x81, 0xec, 0x60, 0x02, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x5c, 0x48, 0x8d, 0x4c, 0x24, 0x5c, 0x4c, 0x8d, 0x44, 0x24, 0x40, 0x48, 0xb8, 0x93, 0x0b, 0xe4, 0xd7, 0x6d, 0xb2, 0x72, 0x0f, 0x48, 0x89, 0x44, 0x24, 0x64, 0x48, 0x8b, 0x42, 0x60, 0x31, 0xd2, 0x4c, 0x8d, 0x64, 0x24, 0x38, 0xff, 0x90, 0x40, 0x01, 0x00, 0x00, 0x48, 0x8d, 0x54, 0x24, 0x6e, 0x48, 0xb8, 0x80, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x41, 0xb9, 0xf2, 0x01, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x4e, 0x48, 0x8b, 0x44, 0x24, 0x40, 0x4c, 0x8d, 0x44, 0x24, 0x4e, 0x48, 0x89, 0x54, 0x24, 0x20, 0xba, 0x0e, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc1, 0xc7, 0x44, 0x24, 0x56, 0x01, 0x73, 0x81, 0x01, 0x66, 0xc7, 0x44, 0x24, 0x5a, 0x00, 0x01, 0xff, 0x50, 0x18, 0x66, 0x8b, 0x84, 0x24, 0x82, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xe2, 0x86, 0xe0, 0x0f, 0xb7, 0xc0, 0x48, 0x8d, 0xb4, 0x04, 0x84, 0x00, 0x00, 0x00, 0x48, 0xb8, 0x41, 0x00, 0x0d, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x38, 0x48, 0x8b, 0x43, 0x40, 0x48, 0x89, 0xc1, 0xff, 0x50, 0x08, 0x8b, 0x54, 0x24, 0x38, 0x4c, 0x8d, 0x56, 0x10, 0x31, 0xc9,
0x49, 0xb8, 0x11, 0x22, 0x33, 0x44, 0x44, 0x33, 0x22, 0x11,   <== gonna overwrite 0x1122334444332211 with the base address of .text section when packing
0x31, 0xc0,        <== xor eax,eax
0x41, 0xb3, 0x01,  <== mov r11b,0x1
0x49, 0xb9, 0x55, 0x66, 0x77, 0x88, 0x88, 0x77, 0x66, 0x55,   <== gonna overwrite 0x5566778888776655 with .text section size when packing
0x0f, 0xb6, 0xe8, 0x41, 0x8a, 0x2c, 0x2a, 0x42, 0x30, 0x2c, 0x00, 0x48, 0x83, 0xf8, 0x01, 0x75, 0x0b, 0x80, 0x7e, 0x11, 0x26, 0x41, 0x0f, 0x44, 0xcb, 0x0f, 0x44, 0xd7, 0x48, 0xff, 0xc0, 0x4c, 0x39, 0xc8, 0x75, 0xdc, 0x84, 0xc9, 0x74, 0x05, 0x66, 0x89, 0x54, 0x24, 0x38, 0x48, 0x8b, 0x43, 0x40, 0x4c, 0x89, 0xe2, 0x48, 0x89, 0xc1, 0xff, 0x50, 0x08,
=========================================================================================================================================================================================
*/
// xor eax,eax and mov r11b,0x1 is able to move so move it like below
/*
=========================================================================================================================================================================================
0x48, 0xb8, 0x6c, 0x76, 0x7f, 0x60, 0x55, 0x74, 0xbe, 0x42, 0x41, 0x54, 0x55, 0x57, 0xbf, 0x42, 0x00, 0x00, 0x00, 0x56, 0x53, 0x48, 0x89, 0xd3, 0x48, 0x81, 0xec, 0x60, 0x02, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x5c, 0x48, 0x8d, 0x4c, 0x24, 0x5c, 0x4c, 0x8d, 0x44, 0x24, 0x40, 0x48, 0xb8, 0x93, 0x0b, 0xe4, 0xd7, 0x6d, 0xb2, 0x72, 0x0f, 0x48, 0x89, 0x44, 0x24, 0x64, 0x48, 0x8b, 0x42, 0x60, 0x31, 0xd2, 0x4c, 0x8d, 0x64, 0x24, 0x38, 0xff, 0x90, 0x40, 0x01, 0x00, 0x00, 0x48, 0x8d, 0x54, 0x24, 0x6e, 0x48, 0xb8, 0x80, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x41, 0xb9, 0xf2, 0x01, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x4e, 0x48, 0x8b, 0x44, 0x24, 0x40, 0x4c, 0x8d, 0x44, 0x24, 0x4e, 0x48, 0x89, 0x54, 0x24, 0x20, 0xba, 0x0e, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc1, 0xc7, 0x44, 0x24, 0x56, 0x01, 0x73, 0x81, 0x01, 0x66, 0xc7, 0x44, 0x24, 0x5a, 0x00, 0x01, 0xff, 0x50, 0x18, 0x66, 0x8b, 0x84, 0x24, 0x82, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xe2, 0x86, 0xe0, 0x0f, 0xb7, 0xc0, 0x48, 0x8d, 0xb4, 0x04, 0x84, 0x00, 0x00, 0x00, 0x48, 0xb8, 0x41, 0x00, 0x0d, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x38, 0x48, 0x8b, 0x43, 0x40, 0x48, 0x89, 0xc1, 0xff, 0x50, 0x08, 0x8b, 0x54, 0x24, 0x38, 0x4c, 0x8d, 0x56, 0x10, 0x31, 0xc9,
0x49, 0xb8, 0x11, 0x22, 0x33, 0x44, 0x44, 0x33, 0x22, 0x11,   <== gonna overwrite 0x1122334444332211 with the base address of .text section when packing
0x49, 0xb9, 0x55, 0x66, 0x77, 0x88, 0x88, 0x77, 0x66, 0x55,   <== gonna overwrite 0x5566778888776655 with .text section size when packing
0x31, 0xc0, 0x41, 0xb3, 0x01, 0x0f, 0xb6, 0xe8, 0x41, 0x8a, 0x2c, 0x2a, 0x42, 0x30, 0x2c, 0x00, 0x48, 0x83, 0xf8, 0x01, 0x75, 0x0b, 0x80, 0x7e, 0x11, 0x26, 0x41, 0x0f, 0x44, 0xcb, 0x0f, 0x44, 0xd7, 0x48, 0xff, 0xc0, 0x4c, 0x39, 0xc8, 0x75, 0xdc, 0x84, 0xc9, 0x74, 0x05, 0x66, 0x89, 0x54, 0x24, 0x38, 0x48, 0x8b, 0x43, 0x40, 0x4c, 0x89, 0xe2, 0x48, 0x89, 0xc1, 0xff, 0x50, 0x08,
=========================================================================================================================================================================================
*/
// then, copy those to the src/custom-packer.cpp
// (make sure to count the number of bytes of the above shellcode in order to memcpy value when packing)


EFI_STATUS EFIAPI UefiMain(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable) {

	EFI_GUID _gEfiTcg2ProtocolGuid = {0x607f766c, 0x7455, 0x42be, { 0x93, 0x0b, 0xe4, 0xd7, 0x6d, 0xb2, 0x72, 0x0f }};

	/*UINT32 EK_HANDLE = 0x81010001;*/
	EFI_TCG2_PROTOCOL *Tcg2Protocol;

#pragma pack(1)
	typedef struct {
		TPM2_COMMAND_HEADER Header;
		TPMI_DH_OBJECT objectHandle;
	} TPM2_READ_PUBLIC_COMMAND;

	typedef struct {
		TPM2_RESPONSE_HEADER Header;
		TPM2B_PUBLIC outPublic;
		TPM2B_NAME name;
		TPM2B_NAME qualifiedName;
	} TPM2_READ_PUBLIC_RESPONSE;

	typedef struct {
		TPMU_PUBLIC_PARMS parameters;
		TPMU_PUBLIC_ID unique;
	} TEMP;

	typedef struct {
		TPMI_RSA_KEY_BITS keyBits;
		UINT32 exponent;
		TPMU_PUBLIC_ID unique;
	} TEMP2;
#pragma pack()
	
	SystemTable->BootServices->LocateProtocol(&_gEfiTcg2ProtocolGuid, NULL, (VOID**)&Tcg2Protocol);

	TPM2_READ_PUBLIC_COMMAND CmdBuffer;
	UINT32 CmdBufferSize;
	TPM2_READ_PUBLIC_RESPONSE RecvBuffer;
	UINT32 RecvBufferSize;

	// send
	CmdBuffer.Header.tag         = 0x0180;     // SwapBytes16(TPMT_ST_NO_SESSIONS)
	CmdBuffer.Header.commandCode = 0x73010000; // SwapBytes32(TPM_CC_ReadPublic)
	CmdBuffer.objectHandle       = 0x01000181; // SwapBytes32(EK_HANDLE)
	CmdBufferSize                = 0xE;        // sizeof(CmdBuffer.Header) + sizeof(CmdBuffer.objectHandle);
	CmdBuffer.Header.paramSize   = 0x0E000000; // SwapBytes32(CmdBufferSize);

	// recv
	RecvBufferSize = sizeof(RecvBuffer);
	Tcg2Protocol->SubmitCommand(Tcg2Protocol, CmdBufferSize, (UINT8*)&CmdBuffer, RecvBufferSize, (UINT8*)&RecvBuffer);


	// parse response manually
	TEMP*  temp  = (TEMP*)( (void*)(&(RecvBuffer.outPublic.publicArea.authPolicy)) + SwapBytes16(RecvBuffer.outPublic.publicArea.authPolicy.size) + 0x2);
	TEMP2* temp2 = (TEMP2*)(&(temp->parameters.rsaDetail.scheme.details));


	// debug print
	UINT64  buf = 0x0000000a000d0041; // L"A\r\n"
	CHAR16 *msg = (CHAR16*)&buf;
	SystemTable->ConOut->OutputString(SystemTable->ConOut, msg);

	// decode
	BYTE* key = temp2->unique.rsa.buffer;
	BYTE* SectionVaddr  = (BYTE*)0x1122334444332211;
	UINT64 SectionSize  = 0x5566778888776655;
	UINT64 i;
	for(i=0; i<SectionSize; i++) {
		SectionVaddr[i] = (SectionVaddr[i] ^ key[i%256]) & 0xff;

		// check if EK is correct
		if(i==1 && key[i]==0x26) {
			*msg = (CHAR16)0x0000000a000d0042; // L"B\r\n"
		}
	}

	SystemTable->ConOut->OutputString(SystemTable->ConOut, msg);

	while(1);
	return 0;
}
